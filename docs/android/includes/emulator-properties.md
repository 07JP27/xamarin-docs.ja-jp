|プロパティ|説明|オプション|
|--- |--- |--- |
|`abi.type`|**ABI の型と**&ndash;エミュー レートされたデバイスの ABI (アプリケーション バイナリ インターフェイス) の種類を指定します。 **X86**オプションは、命令セット呼ば"x86"または"ia-32"。 **X86_64**オプションは、64 ビット x86 命令セット。 **Armeabi v7a**オプションは、ARM 命令が ARM 拡張子 v7 をセットします。 **Arm64 v8a**オプションは、AArch64 をサポートする ARM 命令セット。|x86、x86_64、armeabi-v7a、arm64-v8a|
|`disk.cachePartition`|**パーティションのキャッシュ** &ndash; 、エミュレートされたデバイスが使用になっているかどうかを判断、 **キャッシュ/**デバイス上のパーティションです。 **キャッシュ/** (これが最初に空の) パーティションは、Android が頻繁にアクセスされるデータとアプリのコンポーネントを格納する場所です。 場合に設定**ありません**、エミュレーターを使用しません、**キャッシュ/**パーティションと、その他の`disk.cache`設定は無視されます。|yes、no|
|`disk.cachePartition.path`|**キャッシュ パーティション パス**&ndash;開発用コンピューター上のキャッシュ パーティション イメージ ファイルを指定します。 エミュレーターがに対して、このファイルを使用して、 **キャッシュ/**パーティション。 絶対パスまたはエミュレーターのデータ ディレクトリの相対パスを入力します。 設定されていないエミュレーター作成と呼ばれる空の一時ファイル**cache.img**開発用コンピューターにします。 ファイルが存在しない場合は、空のファイルとして作成されます。 このオプションは無視されます`disk.cachePartition`に設定されている**ありません**です。||
|`disk.cachePartition.size`|**パーティションのサイズをキャッシュ**&ndash;ファイルのサイズ、キャッシュ パーティション (メガバイト単位)。 通常は、既定のキャッシュ サイズである 66 メガバイトを超える非常に大きなファイルをアプリがダウンロードする場合を除き、このオプションを設定する必要はありません。 このオプションは無視されます`disk.cachePartition`に設定されている**ありません**です。||
|`disk.dataPartition.initPath`|**データ パーティションに最初のパス**&ndash;データ パーティションの初期内容を指定します。 ユーザー データをワイプした後には、エミュレーターはユーザー データに指定されたファイルの内容をコピー (既定では、 **userdata qemu.img**) を使用せずに**userdata.img**初期バージョンとして。||
|`disk.dataPartition.path`|**データのパーティションへのパス**&ndash;ユーザー データのパーティション ファイルを指定します。 永続的なユーザー データ ファイルを構成するには、開発コンピューターでファイル名とパスを入力します。 エミュレーターが既定のファイルからイメージを作成する場合は、ファイルが存在しない**userdata.img**、によって指定されたファイル名に格納`disk.dataPartition.path`エミュレーターのシャット ダウン時にユーザー データが引き続き発生するとします。 既定のファイルの名前は、パスを指定しない場合**userdata qemu.img**です。 特殊な値 **<temp>** 作成および一時ファイルを使用するエミュレーターをによりします。 場合`disk.dataPartition.initPath`が設定されている、そのコンテンツは、ブート時に disk.dataPartition.path ファイルにコピーされます。 このオプションを空白のままにすることはできないことに注意してください。||
|`disk.dataPartition.size`|**データのパーティション サイズ**&ndash;ユーザー データのパーティションのサイズをメガバイト単位で指定します。||
|`disk.ramdisk.path`|**Ram ディスク パス**&ndash;ブート パーティション (ramdisk) イメージへのパス。 ramdisk イメージは、システム イメージがマウントされる前にカーネルによって読み込まれるシステム イメージのサブセットです。 通常、ramdisk イメージには、起動時のバイナリと初期化スクリプトが含まれます。 このオプションが指定されていない場合、既定値は**ramdisk.img**エミュレーターのシステム ディレクトリにします。||
|`disk.snapStorage.path`|**スナップショット記憶域パス**&ndash;のすべてのスナップショットの格納場所、スナップショット記憶域ファイルへのパス。 実行中に作成されたスナップショットはすべてこのファイルに保存されます。 エミュレーターの実行中に復元できるのは、このファイルに保存されているスナップショットのみです。 このオプションが指定されていない場合、既定値は、エミュレーターのデータ ディレクトリに snapshots.img はします。||
|`disk.systemPartition.initPath`|**システム パーティション init パス**&ndash;システムのイメージ ファイルの読み取り専用コピーへのパスです。 具体的には、システム ライブラリと API レベルおよびすべてのバリアント型に対応するデータを含むパーティションです。 このパスが指定されていない場合、既定値は、エミュレーターのシステム ディレクトリの system.img はします。||
|`disk.systemPartition.path`|**システム パーティション パス**&ndash;読み取り/書き込みのシステム パーティション イメージへのパス。 このパスが設定されていない場合、一時ファイルが作成されで指定されたファイルの内容から初期化`disk.systemPartition.initPath`です。||
|`disk.systemPartition.size`|**システム パーティション サイズ** &ndash; (メガバイト単位) のシステム パーティションの最適なサイズ。 実際のシステム パーティション イメージがこの設定よりも大きい場合、サイズは無視されます。それ以外の場合は、システム パーティション ファイルを拡大できる最大サイズが指定されます。||
|`hw.accelerometer`|**加速度計**&ndash;エミュー レートされたデバイスに加速度計センサーが含まれるかどうかを判断します。 加速度計は、デバイスが (自動回転で使用される) 向きを判別するのに役立ちます。 加速度計は、3 つのセンサー軸に沿ってデバイスのアクセラレーションを報告します。|yes、no|
|`hw.audioInput`|**オーディオ録音サポート**&ndash;エミュー レートされたデバイスでオーディオを録音できるかどうかを決定します。|yes、no|
|`hw.audioOutput`|**オーディオ再生サポート**&ndash;エミュー レートされたデバイスをオーディオ再生できるかどうかを決定します。|yes、no|
|`hw.battery`|**バッテリ サポート**&ndash;エミュー レートされたデバイスがバッテリで実行できるかどうかを決定します。|yes、no|
|`hw.camera`|**カメラ サポート**&ndash;エミュレートされたデバイスのカメラがあるかどうかを決定します。|yes、no|
|`hw.camera.back`|**背面カメラ**&ndash;背面カメラ (ユーザーから離れてレンズ面) を構成します。 Web カメラにこの値を設定する必要がありますエミュー レートされたデバイスの背面カメラをシミュレートする開発用コンピューター上の web カメラを使用して場合*n*ここで、 _n_ (1 つだけの web カメラがある場合は、web カメラを選択選択**webcam0**)。 設定がエミュレートされる場合、エミュレーターは、ソフトウェアにカメラをシミュレートします。 背面カメラを無効にするには、[なし] にこの値を設定します。 背面カメラを有効にした場合にも有効にすることを確認する`hw.camera`です。|emulated、none、webcam0|
|`hw.camera.front`|**前面カメラ**&ndash;前面カメラ (ユーザーの方にレンズ面) を構成します。 Web カメラにこの値を設定する必要がありますエミュー レートされたデバイスの前面カメラをシミュレートする開発用コンピューター上の web カメラを使用して場合*n*ここで、 _n_ (1 つだけの web カメラがある場合は、web カメラを選択、選択**webcam0**)。 設定がエミュレートされる場合、エミュレーターは、ソフトウェアのカメラをシミュレートします。 前面カメラを無効にするには、[なし] にこの値を設定します。 前面カメラを有効にした場合にも有効にすることを確認する`hw.camera`です。|emulated、none、webcam0|
|`hw.camera.maxHorizontalPixels`|**最大の水平カメラ ピクセル**&ndash;最大の水平方向の解像度 (ピクセル単位) で、エミュレートされたデバイスのカメラのように構成します。||
|`hw.camera.maxVerticalPixels`|**最大の垂直カメラ ピクセル**&ndash;最大の垂直方向の解像度 (ピクセル単位) で、エミュレートされたデバイスのカメラのように構成します。||
|`hw.cpu.arch`|**CPU アーキテクチャ**&ndash;仮想デバイスがエミュレートされる CPU アーキテクチャです。 Intel HAXM ハードウェア アクセラレータを使用している場合は、選択**x86** 32 ビットの CPU に対応します。 選択**x86_64** HAXM アクセラレータを使用したデバイスの 64 ビット。 (SDK Manager での対応の Intel x86 システム イメージをインストールしてください: Intel x86 Atom または Intel x86 Atom_64 などです)。ARM CPU をシミュレートするには、次のように選択します。 **arm**の 32 ビットまたは select **arm64** 64 ビットの ARM CPU に対応します。 ARM ではハードウェア アクセラレータを使用できないため、ARM ベースの仮想デバイスは x86 ベースのものよりかなり遅く実行されることに留意してください。|x86、x86_64、arm、arm64|
|`hw.cpu.model`|**CPU モデル**&ndash;この値が設定されていないまま通常 (から派生した値に設定されます`hw.cpu.arch`明示的に設定されていない場合)。 ただし、実験用にエミュレーター固有の文字列に設定することはできます。||
|`hw.dPad`|**パッド キー** &ndash;エミュー レートされたデバイスが方向パッド (パッド) キーをサポートするかどうかを決定します。 通常、DPad には方向制御を示す 4 つのキーがあります。|yes、no|
|`hw.gps`|**GPS サポート**&ndash;エミュレートされたデバイスの GPS (Global 配置 System) 受信機がかどうかを決定します。|yes、no|
|`hw.gpu.enabled`|**GPU エミュレーション**&ndash;エミュー レートされたデバイスが GPU のエミュレーションをサポートするかどうかを決定します。 有効な場合、GPU エミュレーションでは、画面上で 2D と 3D の両方のグラフィックをレンダリングするために OpenGL ES (Open GL for Embedded Systems) を使用し、関連付けられている GPU エミュレーション モード設定で GPU エミュレーションの実装方法を決定します。|yes、no|
|`hw.gpu.mode`|**GPU エミュレーション モード**&ndash;エミュレーターで GPU のエミュレーションを実装する方法を決定します。 自動を選択すると、エミュレーターは、開発コンピューターの設定に基づいてハードウェアとソフトウェアのアクセラレータを選択します。 ホストを選択すると、エミュレーターを使用して、開発用コンピューターのグラフィックス プロセッサより迅速に表示の GPU のエミュレーションを実行します。 ご使用の GPU は、エミュレーターと互換性がないと、Windows では、ホストではなく角度をしようとすることができます。 角度モードでは、DirectX を使用して、ホストのようなパフォーマンスを提供します。 メサを選択した場合、エミュレーターはグラフィックスを表示するために、メサ 3D ソフトウェア ライブラリを使用します。 開発用コンピューターのグラフィックス プロセッサを使用してレンダリングの問題がある場合は、メサを選択します。 Swiftshader モードは、コンピューターの GPU を使用するよりも若干小さいサイズのパフォーマンスとソフトウェアのグラフィックを表示するために使用できます。 Off オプション (無効にするグラフィックス ハードウェア エミュレーション) であり、非推奨のオプションのいくつかの不適切なレンダリングを引き起こす可能性のある項目は推奨されません。|auto、host、mesa、angle、swiftshader、off|
|`hw.gsmModem`|**GSM モデム サポート**&ndash;エミュー レートされたデバイスが、GSM (Global System for Mobile Communications) のテレフォニー ラジオ システムをサポートしているモデムを含めるかどうかを指定します。|yes、no|
|`hw.initialOrientation`|**最初の画面の向き**&ndash;エミュー レートされたデバイス (縦または横モード) の初期画面の向きを構成します。 縦モードの場合、画面は縦長になります。 横モードの場合、画面は横長になります。 エミュレートされたデバイスを実行するときに、デバイス プロファイルで縦と横の両方がサポートされている場合は、向きを変更できます。|portrait、landscape|
|`hw.keyboard`|**サポートをキーボード**&ndash;エミュー レートされたデバイスが QWERTY キーボードをサポートするかどうかを決定します。|yes、no|
|`hw.keyboard.charmap`|**キーボード charmap 名**&ndash;このデバイスのハードウェア charmap の名前。 注: これは常に既定値**qwerty2**それに応じてシステム イメージを変更した場合を除き、します。 この名前は起動時にカーネルに送信されます。 正しくない名前を使用すると、仮想デバイスが使用できなくなります。||
|`hw.keyboard.lid`|**キーボードのカバー サポート**&ndash;キーボードのサポートを有効にすると、この設定はかどうか、QWERTY キーボード終了/非表示にできるまたは開いた/非表示を決定します。 Hw.keyboard が false に設定されている場合、この設定は無視されます。 注: 既定値は、エミュレートされたデバイスは、API レベル 12 以降を対象とする場合は false です。|yes、no|
|`hw.lcd.backlight`|**LCD のバックライト**&ndash;エミュー レートされたデバイスが、LCD のバックライトがシミュレートされるかどうかを決定します。|yes、no|
|`hw.lcd.density`|**LCD 密度**&ndash;密度に依存しないピクセル単位または配布ポイントで表される、エミュレートされた LCD ディスプレイの密度 (配布ポイントは、仮想のピクセル単位)。 設定が 160 dp の場合、各 dp は 1 物理ピクセルに対応します。 実行時に、Android はこの値を使用して、正しいディスプレイ レンダリングに適切なリソース/アセットを選択してスケーリングします。|120、160、240、213、320|
|`hw.lcd.depth`|**LCD 色深度** &ndash; LCD ディスプレイの推進にビットマップを保持する、エミュレートされたフレームバッファーのカラー ビット数。 この値には 16 ビット (65,536 色表示可能) または 32 ビット (16,777,216 色と透明) を指定できます。 32 ビットを設定すると、エミュレーターの実行速度が若干低下しますが、色の精度が向上します。|16, 32|
|`hw.lcd.height`|**LCD ピクセルの高さ**&ndash;エミュー レートされた LCD ディスプレイの垂直方向のディメンションを構成するピクセルの数。||
|`hw.lcd.width`|**LCD ピクセル幅**&ndash;エミュー レートされた LCD ディスプレイの横幅を構成するピクセルの数。||
|`hw.mainKeys`|**ハードウェアの戻る/ホーム キー** &ndash;エミュー レートされたデバイスがハードウェア バックアップをサポートするかどうかとホーム ナビゲーション ボタンを決定します。 この値を設定することができます**はい**ボタンは、ソフトウェアにのみ実装されている場合。 場合`hw.mainKeys`に設定されている**はい**エミュレーターでは、画面上のナビゲーション ボタンが表示されませんが、エミュレーター側パネルを使用してこれらのボタン"キー"を押すことができます。|yes、no|
|`hw.ramSize`|**デバイスの RAM サイズ**&ndash;メガバイト単位で、エミュレートされたデバイス上の物理 RAM の容量。 既定値は、画面のサイズまたはスキン バージョンから計算されます。 サイズを増やすことでエミュレーターの操作速度を上げることはできますが、その代わり、開発コンピューターからのリソース要求が増えます。||
|`hw.screen`|**画面の種類をタッチ**&ndash;エミュー レートされたデバイスの画面の種類を定義します。 マルチ タッチ スクリーンでは、タッチ インターフェイスで 2 つ以上の指を追跡できます。 タッチ スクリーンでは、1 本指タッチ イベントのみを検出できます。 いいえ-タッチ スクリーンでは、タッチ イベントは検出されません。|touch、multi-touch、no-touch|
|`hw.sdCard`|**SDCard サポート**&ndash;エミュー レートされたデバイスが、挿入と仮想の (セキュリティで保護されたデジタル) SD カードの削除をサポートするかどうかを決定します。 エミュレーターでは、開発用コンピューターに格納されているマウント可能なディスク イメージを使用して、(hw.sdCard.path を参照してください) SD カード デバイスを実際のパーティションをシミュレートします。|yes、no|
|`sdcard.size`|**SDCard サイズ**&ndash;によって指定された位置には、仮想の SD カード ファイルのサイズを指定`hw.sdCard.path`です。 バイト単位でのデバイスで使用できます。 サイズが単純な整数の場合は、バイト単位でサイズが指定されます。 サイズに K、M、G を追加することで、キロバイト、メガバイト、ギガバイト単位でサイズを指定することもできます。 最小サイズは 9 M で、最大サイズは 1023 G です。||
|`hw.sdCard.path`|**SDCard イメージ パス**&ndash;開発用コンピューター上の SD カード パーティション画像ファイルへのパスとファイル名を指定します。 たとえば、このパスに設定する可能性があります**C:\sd\sdcard.img** windows です。||
|`hw.sensors.magnetic_field`|**磁場センサー** &ndash;エミュー レートされたデバイスが磁場センサーをサポートするかどうかを決定します。 磁場センサー (磁力計ともいう) は、3 つのセンサー軸に沿って測定されたアンビエント磁場を報告します。 コンパス読み取り値へのアクセスが必要なアプリに対して、この設定を有効にします。 たとえば、ナビゲーション アプリではこの設定を使用して、ユーザーがどの方向を向いているかを検出する場合があります。|yes、no|
|`hw.sensors.orientation`|**印刷の向きセンサー** &ndash;エミュー レートされたデバイスがセンサーの値についての向きを提供しているかどうかを決定します。 方向センサーは、デバイスが 3 つすべての物理軸 (x、y、z) を中心に回転する角度を測定します。 方向センサーは、Android 2.2 (API レベル 8) の時点で推奨されなくなったことに注意してください。|yes、no|
|`hw.sensors.proximity`|**近接センサー** &ndash;エミュー レートされたデバイスが近接センサーをサポートするかどうかを決定します。 このセンサーは、デバイスの表示画面を基準にオブジェクトの近接度を測定します。 通常、このセンサーは、ハンドセットがユーザーの耳に当てられているかどうかを判別するために使用されます。|yes、no|
|`hw.sensors.temperature`|**温度センサー** &ndash;エミュー レートされたデバイスが、温度センサーをサポートするかどうかを決定します。 このセンサーが摂氏でデバイスの温度を測定 (&deg;C)。|yes、no|
|`hw.touchScreen`|**タッチ スクリーン サポート**&ndash;エミュー レートされたデバイスがタッチ スクリーンをサポートするかどうかを決定します。 タッチ スクリーンは、スクリーン上のオブジェクトを直接操作する場合に使用されます。|yes、no|
|`hw.trackBall`|**ボール サポート**&ndash;エミュー レートされたデバイスが、ボールをサポートするかどうかを決定します。|yes、no|
|`hw.useext4`|**ファイル システムのサポートを EXT4** &ndash;エミュー レートされたデバイスが、パーティションの Linux EXT4 ファイル システムを使用するかどうかを決定します。 現在、ファイル システムの種類は自動検出されるため、このオプションは推奨されておらず、無視されます。|Ｘ|
|`kernel.newDeviceNaming`|**新しいデバイスの命名カーネル**&ndash;カーネルに新しいデバイスの命名規則が必要かどうかを指定するために使用します。 通常、これは Linux 3.10 カーネル以降で使用されます。 場合設定**自動検出**エミュレーターのカーネルに新しいデバイスの命名規則が必要かどうかが自動的に検出します。|autodetect、yes、no|
|`kernel.parameters`|**カーネル パラメーター** &ndash; Linux カーネルのブート パラメーターの文字列を指定します。 既定では、この設定は空白のままになります。||
|`kernel.path`|**カーネル パス** &ndash; Linux カーネルへのパスを指定します。 このパスが指定されていない場合は、カーネル ranchu のエミュレーターのシステム ディレクトリに、エミュレーターが検索されます。||
|`kernel.supportsYaffs2`|**YAFFS2 パーティション サポート**&ndash;カーネルが YAFFS2 をサポートするかどうかを決定 (まだ別フラッシュ ファイル システム 2) パーティションです。 通常、これは Linux 3.10 より前のカーネルにのみ適用されます。 場合設定**自動検出**エミュレーターのカーネルが YAFFS2 ファイル システムをマウントするかどうかが自動的に検出します。|autodetect、yes、no|
|`skin.name`|**スキン名** &ndash; Android エミュレーター スキンの名前。 スキンは、エミュレーター ディスプレイの視覚および制御要素を定義するファイルのコレクションです。開発コンピューターでの AVD のウィンドウの外観を説明します。 スキンは画面のサイズ、ボタン、全体のデザインを説明しますが、アプリの操作には影響しません。||
|`skin.path`|**スキン パス**&ndash;エミュレーター スキン ファイルを含むディレクトリへのパスが skin.name で指定されたこのディレクトリには、hardware.ini レイアウト ファイル、およびスキンの表示要素用のイメージ ファイルが含まれています。||
|`skin.dynamic`|**スキン ダイナミック**&ndash;かどうか、スキンは動的です。 エミュレーターが指定された幅と高さに基づいて特定のサイズのスキンを構築する場合、エミュレーター スキンは動的スキンとなります。|Ｘ|

